{
  "name": "Chat v3 — Section-Aware Letter Generation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat",
        "responseMode": "lastNode",
        "options": {
          "rawBody": false
        }
      },
      "id": "webhook-1",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 300],
      "webhookId": "chat-v3"
    },
    {
      "parameters": {
        "jsCode": "// Extract Auth\n// Pull API key from header and validate it.\n\nconst auth = $input.item.json?.headers?.['x-api-key']\n  || $input.item.json?.headers?.['X-API-Key']\n  || $input.item.json?.query?.api_key\n  || null;\n\nif (!auth) {\n  throw new Error('Missing X-API-Key header');\n}\n\nreturn [{ json: { ...$input.item.json, _auth: { api_key: auth } } }];\n"
      },
      "id": "extract-auth-1",
      "name": "Extract Auth",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "jsCode": "// Resolve Tenant\n// Map the facility_id to a tenant config.\n\nconst body = $input.item.json?.body || $input.item.json || {};\nconst facility_id = String(body.facility_id || body.ctx?.facility_id || 'FAC-DEMO').trim();\n\n// Default tenant resolution — extendable via DB lookup\nconst tenant_id = Number(body.tenant_id || body.ctx?.tenant_id || 1);\nconst schema = 'demo'; // could be looked up from a tenants table\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    _tenant: {\n      tenant_id,\n      facility_id,\n      schema,\n    }\n  }\n}];\n"
      },
      "id": "resolve-tenant-1",
      "name": "Resolve Tenant",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [640, 300]
    },
    {
      "parameters": {
        "jsCode": "// Validate + normalize input\n// Extracts and normalizes all fields from the incoming webhook body.\n\nconst raw = $input.item.json || {};\nconst body = raw.body || raw;\nconst tenant = raw._tenant || {};\n\nconst ctx = body.ctx || {};\n\nconst tenant_id = Number(ctx.tenant_id || tenant.tenant_id || 1);\nconst facility_id = String(ctx.facility_id || tenant.facility_id || body.facility_id || 'FAC-DEMO').trim();\nconst thread_id = String(ctx.thread_id || body.thread_id || '').trim();\nconst case_id = String(ctx.case_id || body.case_id || '').trim();\nconst request_id = String(ctx.request_id || body.request_id || '').trim();\nconst patient_id = String(ctx.patient_id || body.patient_id || '').trim();\n\nconst intent = String(body.intent || 'generate_preauth_letter').trim();\nconst message = String(body.message || '').trim();\n\nconst payer_key = String(body.payer_key || ctx.payer_key || '').trim().toLowerCase() || null;\nconst service_key = String(body.service_key || ctx.service_key || '').trim().toLowerCase() || null;\nconst template_key = String(body.template_key || ctx.template_key || '').trim() || null;\nconst policy_key = String(body.policy_key || ctx.policy_key || '').trim() || null;\n\nconst file_ids = Array.isArray(body.file_ids) ? body.file_ids : [];\nconst non_phi_packet = body.non_phi_packet || null;\n\n// Optional passthrough text (when caller already has template/policy text)\nconst template_text = String(body.template_text || ctx.template_text || '').trim() || null;\nconst policy_text = String(body.policy_text || ctx.policy_text || '').trim() || null;\n\nreturn [{\n  json: {\n    req: raw,\n    tenant_id,\n    facility_id,\n    request_id,\n    non_phi_packet,\n    ctx: {\n      tenant_id,\n      facility_id,\n      thread_id,\n      case_id,\n      request_id,\n      patient_id,\n      intent,\n      message,\n      payer_key,\n      service_key,\n      template_key,\n      policy_key,\n      file_ids,\n      template_text,\n      policy_text,\n      free_text_reason: body.free_text_reason || ctx.free_text_reason || null,\n      requested_dos: body.requested_dos || ctx.requested_dos || null,\n      cpt_code: body.cpt_code || ctx.cpt_code || null,\n      icd10_code: body.icd10_code || ctx.icd10_code || null,\n    }\n  }\n}];\n"
      },
      "id": "validate-normalize-1",
      "name": "Validate + normalize input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build RAG Query\n// Constructs the search query for the RAG vector store.\n\nconst norm = $input.item.json || {};\nconst ctx = norm.ctx || {};\n\nconst payer_key = ctx.payer_key || null;\nconst service_key = ctx.service_key || null;\nconst template_key = ctx.template_key || null;\nconst policy_key = ctx.policy_key || null;\nconst message = ctx.message || '';\nconst intent = ctx.intent || 'generate_preauth_letter';\n\n// Build a composite search query from available context\nconst queryParts = [];\nif (payer_key) queryParts.push(`payer:${payer_key}`);\nif (service_key) queryParts.push(`service:${service_key}`);\nif (template_key) queryParts.push(`template:${template_key}`);\nif (policy_key) queryParts.push(`policy:${policy_key}`);\nif (message) queryParts.push(message);\n\nconst rag_query = queryParts.join(' ').trim() || 'prior authorization letter template';\n\nreturn [{\n  json: {\n    ...norm,\n    rag_query,\n    payer_key,\n    service_key,\n    template_key,\n    policy_key,\n    file_ids: ctx.file_ids || [],\n  }\n}];\n"
      },
      "id": "build-rag-query-1",
      "name": "Build RAG Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "url": "={{ $env.QDRANT_URL || 'http://localhost:6333' }}/collections/{{ $env.QDRANT_COLLECTION || 'clinic_docs' }}/points/search",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"vector\": {{ JSON.stringify($json.embedding || []) }},\n  \"filter\": {\n    \"must\": [\n      { \"key\": \"doc_role\", \"match\": { \"value\": \"template\" } },\n      { \"key\": \"facility_id\", \"match\": { \"value\": \"{{ $json.ctx?.facility_id || 'FAC-DEMO' }}\" } }\n    ]\n  },\n  \"limit\": 3,\n  \"with_payload\": true\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "rag-template-1",
      "name": "RAG: Load Template",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1300, 180]
    },
    {
      "parameters": {
        "url": "={{ $env.QDRANT_URL || 'http://localhost:6333' }}/collections/{{ $env.QDRANT_COLLECTION || 'clinic_docs' }}/points/search",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"vector\": {{ JSON.stringify($json.embedding || []) }},\n  \"filter\": {\n    \"must\": [\n      { \"key\": \"doc_role\", \"match\": { \"value\": \"policy\" } },\n      { \"key\": \"facility_id\", \"match\": { \"value\": \"{{ $json.ctx?.facility_id || 'FAC-DEMO' }}\" } }\n    ]\n  },\n  \"limit\": 3,\n  \"with_payload\": true\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "rag-policy-1",
      "name": "RAG: Load Policy",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1300, 420]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-rag-1",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [1520, 300]
    },
    {
      "parameters": {
        "jsCode": "// Normalize + format response\n// Takes the merged RAG results (template + policy) and normalizes them\n// into a consistent shape for downstream nodes.\n\nconst items = $input.all();\nconst templateItem = items[0]?.json || {};\nconst policyItem = items[1]?.json || items[0]?.json || {};\n\n// RAG template results\nconst templateResults = Array.isArray(templateItem.result)\n  ? templateItem.result\n  : Array.isArray(templateItem)\n    ? templateItem\n    : [];\n\nconst topTemplate = templateResults[0]?.payload || templateResults[0] || {};\n\n// RAG policy results\nconst policyResults = Array.isArray(policyItem.result)\n  ? policyItem.result\n  : Array.isArray(policyItem)\n    ? policyItem\n    : [];\n\nconst topPolicy = policyResults[0]?.payload || policyResults[0] || {};\n\nreturn [{\n  json: {\n    template: {\n      template_text: topTemplate.template_text || topTemplate.text || topTemplate.content || '',\n      template_key: topTemplate.template_key || topTemplate.metadata?.template_key || null,\n      from_file_id: topTemplate.file_id || topTemplate.metadata?.file_id || null,\n      score: templateResults[0]?.score || null,\n    },\n    policy: {\n      policy_text: topPolicy.policy_text || topPolicy.text || topPolicy.content || '',\n      policy_key: topPolicy.policy_key || topPolicy.metadata?.policy_key || null,\n      from_file_id: topPolicy.file_id || topPolicy.metadata?.file_id || null,\n      score: policyResults[0]?.score || null,\n    },\n    payer_key: topPolicy.payer_key || topTemplate.payer_key || null,\n    service_key: topTemplate.service_key || topPolicy.service_key || null,\n  }\n}];\n"
      },
      "id": "normalize-format-1",
      "name": "Normalize + format response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 300]
    },
    {
      "parameters": {
        "jsCode": "// SQL Vars\n// Prepares variables for the DB template and policy lookups.\n\nconst norm = $node['Validate + normalize input'].json || {};\nconst ctx = norm.ctx || {};\nconst rag = $input.item.json || {};\n\nconst tenant_id = ctx.tenant_id || 1;\nconst facility_id = ctx.facility_id || 'FAC-DEMO';\n\n// Template lookup keys\nconst template_key = ctx.template_key\n  || rag?.template?.template_key\n  || null;\n\n// Policy lookup keys  \nconst policy_key = ctx.policy_key\n  || rag?.policy?.policy_key\n  || null;\n\nconst payer_key = ctx.payer_key\n  || rag?.payer_key\n  || null;\n\nconst service_key = ctx.service_key\n  || rag?.service_key\n  || null;\n\nreturn [{\n  json: {\n    tenant_id,\n    facility_id,\n    template_key,\n    policy_key,\n    payer_key,\n    service_key,\n  }\n}];\n"
      },
      "id": "sql-vars-1",
      "name": "SQL Vars",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1960, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT template_id, template_key, template_name, template_text, file_id\nFROM {{ $env.CLINIC_SCHEMA || 'demo' }}.letter_templates\nWHERE tenant_id = {{ $json.tenant_id }}\n  AND facility_id = '{{ $json.facility_id }}'\n  AND is_active = true\n  AND (\n    template_key = '{{ $json.template_key }}'\n    OR template_id = '{{ $json.template_key }}'\n  )\nORDER BY version DESC\nLIMIT 1;",
        "options": {}
      },
      "id": "db-template-1",
      "name": "Load Template",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2180, 180],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Clinic Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT policy_id, policy_key, policy_name, policy_text, file_id\nFROM {{ $env.CLINIC_SCHEMA || 'demo' }}.payer_policies\nWHERE tenant_id = {{ $json.tenant_id }}\n  AND facility_id = '{{ $json.facility_id }}'\n  AND (\n    policy_key = '{{ $json.policy_key }}'\n    OR policy_id = '{{ $json.policy_key }}'\n    OR (payer_id IN (\n      SELECT payer_id FROM {{ $env.CLINIC_SCHEMA || 'demo' }}.payers\n      WHERE payer_key = '{{ $json.payer_key }}'\n      AND tenant_id = {{ $json.tenant_id }}\n      AND facility_id = '{{ $json.facility_id }}'\n    ))\n  )\n  AND (expiration_date IS NULL OR expiration_date >= CURRENT_DATE)\nORDER BY effective_date DESC NULLS LAST\nLIMIT 1;",
        "options": {}
      },
      "id": "db-policy-1",
      "name": "DB: Load Policy",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2180, 420],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Clinic Postgres"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-rag-policy-1",
      "name": "Merge (RAG + Policy)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [2400, 300]
    },
    {
      "parameters": {
        "jsCode": "// Pick Final Text (DB > RAG)\n// DB text is authoritative. Falls back to RAG if DB has nothing.\n// Also passes through section payloads if present.\n\nfunction getNodeJson(name) {\n  try { return $node[name].json; } catch { return null; }\n}\nfunction safeItems(name) {\n  try { return $items(name) || []; } catch { return []; }\n}\n\nconst norm = getNodeJson(\"Validate + normalize input\") || {};\nconst ctx = norm.ctx || {};\n\n// --- DB sources ---\nconst dbTemplateItems = safeItems(\"Load Template\");\nconst dbPolicyItems = safeItems(\"DB: Load Policy\");\n\nconst dbTemplate = dbTemplateItems[0]?.json || {};\nconst dbPolicy = dbPolicyItems[0]?.json || {};\n\nconst dbTemplateText = String(dbTemplate.template_text || \"\").trim();\nconst dbPolicyText = String(dbPolicy.policy_text || \"\").trim();\n\n// --- RAG sources (from Normalize + format response) ---\nconst rag = getNodeJson(\"Normalize + format response\") || {};\n\nconst ragTemplateText = String(rag?.template?.template_text || \"\").trim();\nconst ragPolicyText = String(rag?.policy?.policy_text || \"\").trim();\n\n// --- Passthrough text from request body ---\nconst passthroughTemplate = String(ctx.template_text || \"\").trim();\nconst passthroughPolicy = String(ctx.policy_text || \"\").trim();\n\n// --- Pick best: passthrough > DB > RAG ---\nconst template_text = passthroughTemplate || dbTemplateText || ragTemplateText;\nconst policy_text = passthroughPolicy || dbPolicyText || ragPolicyText;\n\nconst template_source = passthroughTemplate ? \"passthrough\" : dbTemplateText ? \"db\" : ragTemplateText ? \"rag\" : \"none\";\nconst policy_source = passthroughPolicy ? \"passthrough\" : dbPolicyText ? \"db\" : ragPolicyText ? \"rag\" : \"none\";\n\n// --- Section payloads (from non_phi_packet.sections or body.sections) ---\nconst packet = norm.non_phi_packet || norm?.req?.body?.non_phi_packet || {};\nconst sections = Array.isArray(packet.sections) ? packet.sections : \n                 Array.isArray(norm?.req?.body?.sections) ? norm.req.body.sections : [];\n\n// --- Template + policy metadata ---\nconst template_key = dbTemplate.template_key || rag?.template?.template_key || ctx.template_key || null;\nconst policy_key = dbPolicy.policy_key || rag?.policy?.metadata?.policy_key || ctx.policy_key || null;\n\nreturn [{\n  json: {\n    success: !!template_text,\n    \n    request_id: ctx.request_id || norm.request_id || null,\n    tenant_id: ctx.tenant_id || norm.tenant_id || null,\n    facility_id: ctx.facility_id || norm.facility_id || null,\n\n    payer_key: ctx.payer_key || rag?.payer_key || null,\n    service_key: ctx.service_key || rag?.service_key || null,\n\n    template_text,\n    policy_text,\n    template_source,\n    policy_source,\n\n    template_key,\n    policy_key,\n    \n    template_file_id: dbTemplate.file_id || rag?.template?.from_file_id || null,\n    policy_file_id: dbPolicy.file_id || rag?.policy?.from_file_id || null,\n\n    // Section data for section-based generation\n    has_sections: sections.length > 0,\n    sections,\n    \n    // Payer policy criteria from the generate-sections endpoint\n    policy_criteria: packet.policy_criteria || null,\n\n    _debug: {\n      template_source,\n      policy_source,\n      db_template_len: dbTemplateText.length,\n      rag_template_len: ragTemplateText.length,\n      db_policy_len: dbPolicyText.length,\n      rag_policy_len: ragPolicyText.length,\n      section_count: sections.length,\n    },\n  }\n}];\n"
      },
      "id": "pick-final-text-1",
      "name": "Pick Final Text (DB > RAG)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2128, 48]
    },
    {
      "parameters": {
        "jsCode": "// Build Letter Prompt (v3 — section-aware)\n// Supports both monolithic and section-based generation.\n// Section data comes from Pick Final Text (DB > RAG) node.\n\nfunction getNodeJson(name) {\n  try { return $node[name].json; } catch { return null; }\n}\nfunction isObj(x) { return x && typeof x === \"object\" && !Array.isArray(x); }\nfunction pick(...vals) {\n  for (const v of vals) {\n    if (v === null || v === undefined) continue;\n    if (typeof v === \"string\") { const s = v.trim(); if (s) return s; continue; }\n    return v;\n  }\n  return null;\n}\nfunction htmlDecode(s) {\n  return String(s || \"\")\n    .replace(/&#0;/g, \"\").replace(/&gt;/g, \">\").replace(/&lt;/g, \"<\")\n    .replace(/&amp;/g, \"&\").replace(/&quot;/g, \"\\\"\").replace(/&#39;/g, \"'\")\n    .replace(/&mdash;/g, \"\\u2014\").replace(/&ndash;/g, \"\\u2013\");\n}\n\n// --- Normalized input ---\nconst norm = getNodeJson(\"Validate + normalize input\") || {};\nconst ctx = (norm && isObj(norm.ctx)) ? norm.ctx : (isObj($json.ctx) ? $json.ctx : {});\n\n// --- Pick Final Text (DB > RAG) ---\nconst finalText = getNodeJson(\"Pick Final Text (DB > RAG)\") || null;\nconst ragNode = finalText || getNodeJson(\"Normalize + format response\") || null;\nconst root = $json || {};\n\n// --- Template + Policy text ---\nconst template_text = htmlDecode(String(\n  pick(\n    finalText?.template_text,\n    ragNode?.template?.template_text,\n    ragNode?.template_text,\n    root?.template?.template_text,\n    root?.template_text\n  ) || \"\"\n)).trim();\n\nconst policy_text = htmlDecode(String(\n  pick(\n    finalText?.policy_text,\n    ragNode?.policy?.policy_text,\n    ragNode?.policy_text,\n    root?.policy?.policy_text,\n    root?.policy_text\n  ) || \"\"\n)).trim();\n\n// --- NON-PHI PACKET ---\nconst non_phi_packet = pick(\n  norm?.non_phi_packet, norm?.req?.body?.non_phi_packet, norm?.req?.non_phi_packet,\n  root?.non_phi_packet, root?.req?.body?.non_phi_packet, ctx?.non_phi_packet, null\n) || null;\n\n// --- Sections (from Pick Final Text or packet) ---\nconst sections = finalText?.sections || non_phi_packet?.sections || [];\nconst has_sections = Array.isArray(sections) && sections.length > 0;\nconst policy_criteria = finalText?.policy_criteria || non_phi_packet?.policy_criteria || null;\n\n// --- Validate ---\nif (!template_text) throw new Error(\"Missing template_text.\");\nif (!non_phi_packet) throw new Error(\"Missing non_phi_packet.\");\n\n// --- Request details ---\nconst req = {\n  requested_dos: ctx.requested_dos ?? null,\n  cpt_code: ctx.cpt_code ?? null,\n  icd10_code: ctx.icd10_code ?? null,\n  reason: ctx.free_text_reason ?? ctx.reason ?? null,\n};\n\n// --- Build prompts ---\nlet system, user;\n\nif (has_sections) {\n  // SECTION-BASED GENERATION\n  system = [\n    \"You are a clinical prior-authorization letter generator.\",\n    \"You will receive SECTIONS to generate. Each section has an instruction and a scaffold showing the expected format.\",\n    \"Generate EACH section following its instruction. Use the patient data and policy criteria provided.\",\n    \"Maintain a professional, clinical tone throughout.\",\n    \"Use NON_PHI_PACKET for patient details, coverage, diagnoses, imaging, therapy, meds.\",\n    \"Use POLICY_CRITERIA to align evidence against each requirement.\",\n    'If data is missing, write \\\"[MISSING: ...]\\\" rather than inventing.',\n    \"Return the COMPLETE letter with all sections assembled in order.\",\n    \"Return ONLY the final letter text. No JSON. No markdown fences.\",\n  ].join(\"\\n\");\n\n  const sectionPrompts = sections.map((sec, idx) => {\n    const parts = [`--- SECTION ${idx + 1}: ${sec.section_name.toUpperCase()} ---`];\n    parts.push(`Instruction: ${sec.instruction_prompt}`);\n    if (sec.scaffold_text) parts.push(`Format/Scaffold:\\n${sec.scaffold_text}`);\n    if (sec.policy_criteria) parts.push(`Relevant Policy Criteria:\\n${JSON.stringify(sec.policy_criteria, null, 2)}`);\n    return parts.join(\"\\n\");\n  });\n\n  user = [\n    \"OVERALL TEMPLATE REFERENCE:\",\n    template_text,\n    \"\",\n    \"POLICY_CRITERIA (overall):\",\n    policy_criteria ? JSON.stringify(policy_criteria, null, 2) : (policy_text || \"[none]\"),\n    \"\",\n    \"SECTIONS TO GENERATE:\",\n    ...sectionPrompts,\n    \"\",\n    \"NON_PHI_PACKET:\",\n    JSON.stringify(non_phi_packet, null, 2),\n  ].join(\"\\n\");\n} else {\n  // MONOLITHIC GENERATION (original behavior)\n  system = [\n    \"You are a clinical prior-authorization letter generator.\",\n    \"Follow the TEMPLATE exactly for structure and field placement.\",\n    \"Use NON_PHI_PACKET for patient details, coverage, diagnoses, imaging, therapy, meds, and notes.\",\n    \"Use POLICY_CRITERIA as requirements; cite relevant criteria when possible.\",\n    'If something is missing, write \\\"[MISSING: ...]\\\" rather than inventing.',\n    \"Return ONLY the final letter text. No JSON. No markdown fences.\",\n  ].join(\"\\n\");\n\n  user = [\n    \"TEMPLATE:\", template_text, \"\",\n    \"POLICY_CRITERIA (may be empty):\", policy_text || \"[none]\", \"\",\n    \"REQUEST_DETAILS:\", JSON.stringify(req, null, 2), \"\",\n    \"NON_PHI_PACKET:\", JSON.stringify(non_phi_packet, null, 2),\n  ].join(\"\\n\");\n}\n\n// --- File IDs ---\nconst file_ids =\n  (Array.isArray(ctx.file_ids) ? ctx.file_ids : null) ||\n  (Array.isArray(norm?.req?.body?.file_ids) ? norm.req.body.file_ids : null) ||\n  [];\n\nreturn [{\n  json: {\n    request_id: ctx.request_id ?? norm?.request_id ?? null,\n    tenant_id: ctx.tenant_id ?? norm?.tenant_id ?? null,\n    facility_id: ctx.facility_id ?? norm?.facility_id ?? null,\n    patient_id: ctx.patient_id ?? null,\n    thread_id: ctx.thread_id ?? null,\n\n    payer_key: ctx.payer_key ?? ragNode?.payer_key ?? null,\n    service_key: ctx.service_key ?? ragNode?.service_key ?? null,\n    template_key: ctx.template_key ?? finalText?.template_key ?? null,\n    policy_key: ctx.policy_key ?? finalText?.policy_key ?? null,\n\n    template_file_id: finalText?.template_file_id ?? ragNode?.template?.from_file_id ?? null,\n    policy_file_id: finalText?.policy_file_id ?? ragNode?.policy?.from_file_id ?? null,\n\n    file_ids,\n    prompt: { system, user },\n    generation_mode: has_sections ? \"section_based\" : \"monolithic\",\n    section_count: sections.length,\n\n    _debug: {\n      template_from: finalText ? \"Pick Final Text (DB > RAG)\" : \"Normalize + format response\",\n      non_phi_from: norm?.non_phi_packet ? \"norm.non_phi_packet\" : \"fallback\",\n      had_policy: !!policy_text,\n      generation_mode: has_sections ? \"section_based\" : \"monolithic\",\n      section_count: sections.length,\n    },\n  }\n}];\n"
      },
      "id": "build-letter-prompt-1",
      "name": "Build Letter Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2840, 300]
    },
    {
      "parameters": {
        "model": "={{ $env.LLM_MODEL || 'llama3' }}",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "={{ $json.prompt.system }}"
            },
            {
              "role": "user",
              "content": "={{ $json.prompt.user }}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 4096
        }
      },
      "id": "llm-1",
      "name": "LLM",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3060, 300],
      "notes": "Calls the LLM (Ollama / OpenAI-compatible endpoint) with the assembled prompt."
    },
    {
      "parameters": {
        "jsCode": "// Normalize Output\n// Extracts the letter text from the LLM response and normalizes it.\n\nconst raw = $input.item.json || {};\nconst prompt = $node['Build Letter Prompt'].json || {};\n\n// Common LLM response shapes\nlet letter_text = '';\n\nif (typeof raw === 'string') {\n  letter_text = raw;\n} else if (raw.message?.content) {\n  letter_text = raw.message.content;\n} else if (raw.choices?.[0]?.message?.content) {\n  letter_text = raw.choices[0].message.content;\n} else if (raw.response) {\n  letter_text = raw.response;\n} else if (raw.text) {\n  letter_text = raw.text;\n} else if (raw.output) {\n  letter_text = raw.output;\n}\n\nletter_text = String(letter_text || '').trim();\n\n// Strip markdown fences if the LLM wrapped them\nletter_text = letter_text\n  .replace(/^```[\\w]*\\n?/gm, '')\n  .replace(/\\n?```$/gm, '')\n  .trim();\n\nreturn [{\n  json: {\n    success: !!letter_text,\n    letter_text,\n    request_id: prompt.request_id || null,\n    tenant_id: prompt.tenant_id || null,\n    facility_id: prompt.facility_id || null,\n    patient_id: prompt.patient_id || null,\n    thread_id: prompt.thread_id || null,\n    payer_key: prompt.payer_key || null,\n    service_key: prompt.service_key || null,\n    template_key: prompt.template_key || null,\n    policy_key: prompt.policy_key || null,\n    template_file_id: prompt.template_file_id || null,\n    policy_file_id: prompt.policy_file_id || null,\n    file_ids: prompt.file_ids || [],\n    generation_mode: prompt.generation_mode || 'monolithic',\n    section_count: prompt.section_count || 0,\n  }\n}];\n"
      },
      "id": "normalize-output-1",
      "name": "Normalize Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3280, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": {{ $json.success }},\n  \"letter_text\": {{ JSON.stringify($json.letter_text || '') }},\n  \"assistant_text\": {{ JSON.stringify($json.letter_text || '') }},\n  \"request_id\": {{ JSON.stringify($json.request_id) }},\n  \"thread_id\": {{ JSON.stringify($json.thread_id) }},\n  \"tenant_id\": {{ $json.tenant_id || 'null' }},\n  \"facility_id\": {{ JSON.stringify($json.facility_id) }},\n  \"patient_id\": {{ JSON.stringify($json.patient_id) }},\n  \"payer_key\": {{ JSON.stringify($json.payer_key) }},\n  \"service_key\": {{ JSON.stringify($json.service_key) }},\n  \"template_key\": {{ JSON.stringify($json.template_key) }},\n  \"policy_key\": {{ JSON.stringify($json.policy_key) }},\n  \"generation_mode\": {{ JSON.stringify($json.generation_mode || 'monolithic') }},\n  \"section_count\": {{ $json.section_count || 0 }}\n}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-1",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3500, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Auth",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Auth": {
      "main": [
        [
          {
            "node": "Resolve Tenant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Tenant": {
      "main": [
        [
          {
            "node": "Validate + normalize input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate + normalize input": {
      "main": [
        [
          {
            "node": "Build RAG Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build RAG Query": {
      "main": [
        [
          {
            "node": "RAG: Load Template",
            "type": "main",
            "index": 0
          },
          {
            "node": "RAG: Load Policy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG: Load Template": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG: Load Policy": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Normalize + format response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize + format response": {
      "main": [
        [
          {
            "node": "SQL Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Vars": {
      "main": [
        [
          {
            "node": "Load Template",
            "type": "main",
            "index": 0
          },
          {
            "node": "DB: Load Policy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Template": {
      "main": [
        [
          {
            "node": "Merge (RAG + Policy)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB: Load Policy": {
      "main": [
        [
          {
            "node": "Merge (RAG + Policy)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge (RAG + Policy)": {
      "main": [
        [
          {
            "node": "Pick Final Text (DB > RAG)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pick Final Text (DB > RAG)": {
      "main": [
        [
          {
            "node": "Build Letter Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Letter Prompt": {
      "main": [
        [
          {
            "node": "LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM": {
      "main": [
        [
          {
            "node": "Normalize Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Output": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "instanceId": "clinic-preauth-v3"
  },
  "tags": [
    {
      "name": "chat",
      "id": "1"
    },
    {
      "name": "v3-sections",
      "id": "2"
    },
    {
      "name": "preauth",
      "id": "3"
    }
  ]
}